# 4.2 网络层：路由器体系结构

## 本章目录

1. [路由器工作原理概述](#路由器工作原理概述)
2. [路由器硬件架构](#路由器硬件架构)
3. [输入端口处理](#输入端口处理)
4. [交换结构](#交换结构)
5. [输出端口处理](#输出端口处理)
6. [排队理论与分组调度](#排队理论与分组调度)

---

## 路由器工作原理概述

### 路由器的基本功能

> **路由器 (Router)**
> 
> 网络层设备，负责根据目标IP地址将分组从输入端口转发到正确的输出端口，是Internet的核心转发设备。

#### 路由器vs交换机区别

**功能对比**：

| 特征 | 路由器 | 交换机 |
|------|--------|--------|
| 工作层次 | 网络层(L3) | 数据链路层(L2) |
| 转发依据 | IP地址 | MAC地址 |
| 转发表 | 路由表 | MAC地址表 |
| 分组处理 | 需要处理IP头部 | 透明转发 |
| 网络范围 | 跨网络 | 单一网络 |
| 广播处理 | 不转发广播 | 泛洪广播 |
| 复杂度 | 高 | 较低 |

#### 路由器功能分离

**数据平面 vs 控制平面**：

```mermaid
graph TD
    A["控制平面<br/>• 路由协议 (OSPF, BGP)<br/>• 路由表构建<br/>• 网络拓扑发现<br/>• 路由决策"] --> |路由信息下发| B["数据平面<br/>• 分组转发<br/>• 转发表查找<br/>• 输入输出处理<br/>• 排队调度"]
    
    A -.- C["第5章内容"]
    B -.- D["本章重点"]
    
    style A fill:#e3f2fd,color:#333
    style B fill:#e8f5e8,color:#333
    style C fill:#f5f5f5,color:#333
    style D fill:#f5f5f5,color:#333
```

**时间尺度差异**：
- **控制平面**：秒级、分钟级（路由收敛）
- **数据平面**：纳秒级、微秒级（分组转发）

---

## 路由器硬件架构

### 通用路由器架构

#### 基本组件构成

**路由器内部结构**：

```mermaid
graph TB
    subgraph Router ["路由器硬件架构"]
        RP["路由处理器<br/>(控制平面功能)"]
        
        subgraph Input ["输入端口组"]
            IP1["输入端口1<br/>• 线路端接<br/>• 物理层处理<br/>• 数据链路处理<br/>• 转发表查找<br/>• 排队缓存"]
            IP2["输入端口2"]
            IPn["输入端口N"]
        end
        
        subgraph Switch ["交换结构"]
            SM["交换矩阵"]
        end
        
        subgraph Output ["输出端口组"]
            OP1["输出端口1<br/>• 数据链路处理<br/>• 线路端接<br/>• 物理层处理<br/>• 排队调度<br/>• 缓存管理"]
            OP2["输出端口2"]
            OPn["输出端口N"]
        end
        
        RP --> IP1
        RP --> IP2
        RP --> IPn
        RP --> OP1
        RP --> OP2
        RP --> OPn
        
        IP1 <--> SM
        IP2 <--> SM
        IPn <--> SM
        
        SM <--> OP1
        SM <--> OP2
        SM <--> OPn
    end
    
    style RP fill:#e3f2fd,color:#333
    style SM fill:#fff3e0,color:#333
    style IP1 fill:#e8f5e8,color:#333
    style IP2 fill:#e8f5e8,color:#333
    style IPn fill:#e8f5e8,color:#333
    style OP1 fill:#e8f5e8,color:#333
    style OP2 fill:#e8f5e8,color:#333
    style OPn fill:#e8f5e8,color:#333
```

**关键特性**：
- **分布式处理**：每个端口独立处理
- **并行转发**：多个分组同时处理  
- **硬件加速**：ASIC/TCAM实现高速查找
- **缓存管理**：输入/输出端口排队

#### 路由器性能指标

**关键性能参数**：

```mermaid
graph TD
    A["性能指标分类"] --> B["转发性能"]
    A --> C["表项容量"]
    A --> D["可靠性"]
    
    B --> B1["转发速率：Mpps<br/>(百万包/秒)"]
    B --> B2["吞吐量：Gbps/Tbps"]
    B --> B3["端口密度：端口数量"]
    B --> B4["延迟：微秒级转发延迟"]
    
    C --> C1["路由表：百万级条目"]
    C --> C2["ARP表：数万级条目"]
    C --> C3["ACL规则：数千级规则"]
    
    D --> D1["MTBF：平均故障间隔时间"]
    D --> D2["冗余设计：电源、风扇、引擎卡"]
    D --> D3["热插拔：在线维护能力"]
    
    style A fill:#f5f5f5,color:#333
    style B fill:#e8f5e8,color:#333
    style C fill:#fff3e0,color:#333
    style D fill:#f3e5f5,color:#333
    style B1 fill:#e8f5e8,color:#333
    style B2 fill:#e8f5e8,color:#333
    style B3 fill:#e8f5e8,color:#333
    style B4 fill:#e8f5e8,color:#333
    style C1 fill:#fff3e0,color:#333
    style C2 fill:#fff3e0,color:#333
    style C3 fill:#fff3e0,color:#333
    style D1 fill:#f3e5f5,color:#333
    style D2 fill:#f3e5f5,color:#333
    style D3 fill:#f3e5f5,color:#333
```

**典型设备规格 (2024年)**：
- **企业级路由器**：1-10 Gbps
- **运营商边缘路由器**：100 Gbps-1 Tbps  
- **核心路由器**：10-100 Tbps
- **数据中心交换机**：25.6-51.2 Tbps

---

## 输入端口处理

### 输入端口功能架构

#### 多层处理流程

**输入端口处理过程**：

```mermaid
graph LR
    A["物理层处理"] --> B["数据链路层处理"]
    B --> C["转发查找处理"]
    C --> D["排队缓存"]
    
    A -.-> A1["• 信号恢复<br/>• 时钟恢复<br/>• 编码解码"]
    B -.-> B1["• 帧同步<br/>• 错误检测<br/>• 帧解析"]
    C -.-> C1["• 路由查找<br/>• ACL检查<br/>• QoS分类"]
    D -.-> D1["• 流量整形<br/>• 拥塞控制<br/>• 缓存管理"]
    
    style A fill:#fff3e0,color:#333
    style B fill:#e8f5e8,color:#333
    style C fill:#e3f2fd,color:#333
    style D fill:#f5f5f5,color:#333
    style A1 fill:#fff3e0,color:#333
    style B1 fill:#e8f5e8,color:#333
    style C1 fill:#e3f2fd,color:#333
    style D1 fill:#f5f5f5,color:#333
```

#### 转发表查找算法

**高速查找技术**：

```
转发表查找方法演进：
1. 线性查找 O(N)：
   for (每条路由表项):
       if (目标IP匹配前缀):
           return 下一跳
   
   问题：速度慢，不适用于大型路由表

2. 二分查找 O(log N)：
   对路由表按前缀长度排序
   使用二分查找算法
   
   问题：最长前缀匹配复杂

3. 前缀树 (Trie)：
   每个节点代表一位
   路径代表IP前缀
   叶子节点存储下一跳信息
   
   优点：支持最长前缀匹配
   缺点：内存使用量大

4. 内容可寻址存储器 (CAM/TCAM)：
   硬件并行查找
   纳秒级查找速度
   支持通配符匹配
   
   应用：现代高速路由器主流方案

TCAM查找示例：
目标IP: 192.168.1.100 (11000000.10101000.00000001.01100100)

TCAM表项：
192.168.0.0/16  → Port 1  (匹配16位)
192.168.1.0/24  → Port 2  (匹配24位) ← 最长匹配
0.0.0.0/0       → Port 3  (默认路由)

结果：选择Port 2 (最长前缀匹配)
```

#### 访问控制列表 (ACL)

**分组过滤处理**：

```
ACL处理流程：
分组到达 → 五元组提取 → ACL规则匹配 → 动作执行
           (src IP,      (并行匹配)   (允许/拒绝/
            dst IP,      (优先级排序)  标记/限速)
            src Port,
            dst Port,
            Protocol)

ACL规则示例：
规则1: permit ip 192.168.1.0/24 any eq 80
规则2: deny ip 10.0.0.0/8 any
规则3: permit ip any any

匹配过程：
1. 检查源IP是否为192.168.1.0/24且目标端口80
2. 检查源IP是否为10.0.0.0/8 (拒绝)
3. 默认允许其他流量

性能考虑：
• 规则数量：影响查找速度
• 规则顺序：按优先级排列
• 硬件加速：使用TCAM并行匹配
```

---

## 交换结构

### 交换结构类型

#### 三种主要架构

**交换结构对比**：

#### 1. 基于内存的交换

```mermaid
graph TB
    subgraph Memory ["基于内存的交换"]
        A["输入端口1"] --> C["共享系统总线"]
        B["输入端口2"] --> C
        D["..."] --> C
        C --> E["CPU"]
        C --> F["内存"]
        C --> G["输出端口1"]
        C --> H["输出端口2"]
        C --> I["..."]
    end
    
    style A fill:#e8f5e8,color:#333
    style B fill:#e8f5e8,color:#333
    style D fill:#e8f5e8,color:#333
    style C fill:#ffebee,color:#333
    style E fill:#e3f2fd,color:#333
    style F fill:#fff3e0,color:#333
    style G fill:#e8f5e8,color:#333
    style H fill:#e8f5e8,color:#333
    style I fill:#e8f5e8,color:#333
```

**特点**：
- 早期路由器设计
- CPU参与每个分组转发
- 速度受内存带宽限制
- 适用于低速设备

#### 2. 基于总线的交换
特点：
• 所有端口共享总线带宽
• 同时只能有一个传输
• 总线争用导致性能瓶颈
• 适用于中速设备



```mermaid
graph LR
    subgraph Bus ["基于总线的交换"]
        A["输入端口1"] <--> C["共享总线"]
        B["输入端口2"] <--> C
        D["..."] <--> C
        C <--> E["输出端口1"]
        C <--> F["输出端口2"]
        C <--> G["..."]
    end
    
    style A fill:#e8f5e8,color:#333
    style B fill:#e8f5e8,color:#333
    style D fill:#e8f5e8,color:#333
    style C fill:#ffebee,color:#333
    style E fill:#e8f5e8,color:#333
    style F fill:#e8f5e8,color:#333
    style G fill:#e8f5e8,color:#333
```

**特点**：
- 所有端口共享总线带宽
- 同时只能有一个传输
- 总线争用导致性能瓶颈
- 适用于中速设备

#### 3. 基于交叉开关的交换
```
输入端口                输出端口

  1 ──○────○────○──── 1
      │    │    │
  2 ──○────●────○──── 2  (●表示连接)
      │    │    │
  3 ──○────○────○──── 3
```
```mermaid
graph LR
    subgraph Crossbar ["基于交叉开关的交换"]
        A["输入端口1"] --> X1["交叉点1-1"]
        A --> X2["交叉点1-2"]
        A --> X3["交叉点1-3"]
        
        B["输入端口2"] --> Y1["交叉点2-1"]
        B --> Y2["交叉点2-2"]
        B --> Y3["交叉点2-3"]
        
        C["输入端口3"] --> Z1["交叉点3-1"]
        C --> Z2["交叉点3-2"]
        C --> Z3["交叉点3-3"]
        
        X1 --> D["输出端口1"]
        Y1 --> D
        Z1 --> D
        
        X2 --> E["输出端口2"]
        Y2 --> E
        Z2 --> E
        
        X3 --> F["输出端口3"]
        Y3 --> F
        Z3 --> F
    end
    
    style A fill:#e8f5e8,color:#333
    style B fill:#e8f5e8,color:#333
    style C fill:#e8f5e8,color:#333
    style D fill:#e8f5e8,color:#333
    style E fill:#e8f5e8,color:#333
    style F fill:#e8f5e8,color:#333
    style X1 fill:#fff3e0,color:#333
    style X2 fill:#fff3e0,color:#333
    style X3 fill:#fff3e0,color:#333
    style Y1 fill:#fff3e0,color:#333
    style Y2 fill:#f3e5f5,color:#333
    style Y3 fill:#fff3e0,color:#333
    style Z1 fill:#fff3e0,color:#333
    style Z2 fill:#fff3e0,color:#333
    style Z3 fill:#fff3e0,color:#333
```

**特点**：
- 非阻塞交换架构
- 多个并行连接
- 最高性能方案
- 现代高速路由器标准

#### 交换结构调度算法

**并行传输调度**：

```
交叉开关调度问题：
多个输入端口可能同时要发送到同一输出端口

调度算法：
1. 最大权重匹配 (Maximum Weight Matching)：
   • 为每个输入-输出对分配权重
   • 寻找总权重最大的匹配
   • NP-hard问题，需要近似算法

2. 轮询仲裁 (Round-Robin Arbitration)：
   • 按顺序为每个输入端口分配服务
   • 公平性好，实现简单
   • 不考虑流量优先级

3. 虚拟输出队列 (Virtual Output Queues)：
   输入端口为每个输出端口维护单独队列
   避免队首阻塞 (Head-of-Line Blocking)
   
   传统单队列问题：
   输入队列: [to Port1] [to Port2] [to Port1]
                ↑        X         X
              Port1忙时，到Port2的分组被阻塞
   
   VOQ解决方案：
   到Port1队列: [分组1] [分组3]
   到Port2队列: [分组2]
   到Port3队列: []
   ...
   各队列独立调度，消除队首阻塞

现代实现：
• iSLIP算法：近似最大权重匹配
• PIM算法：并行迭代匹配  
• 硬件实现：纳秒级调度决策
```

---

## 输出端口处理

### 输出端口功能

#### 输出处理流程

**输出端口架构**：

```mermaid
graph LR
    A["交换结构"] --> B["输出队列"]
    B --> C["分组调度"]
    C --> D["数据链路处理"]
    D --> E["物理层发送"]
    
    B -.-> B1["• 缓存管理<br/>• 拥塞检测"]
    C -.-> C1["• QoS调度<br/>• 流量整形"]
    D -.-> D1["• 帧封装<br/>• 错误检测"]
    E -.-> E1["• 信号发送<br/>• 时钟同步"]
    
    style A fill:#fff3e0,color:#333
    style B fill:#e8f5e8,color:#333
    style C fill:#e3f2fd,color:#333
    style D fill:#f3e5f5,color:#333
    style E fill:#fff3e0,color:#333
    style B1 fill:#e8f5e8,color:#333
    style C1 fill:#e3f2fd,color:#333
    style D1 fill:#f3e5f5,color:#333
    style E1 fill:#fff3e0,color:#333
```

```mermaid
graph TB
    subgraph Output ["输出端口处理"]
        subgraph Queue ["输出队列"]
            Q1["高优先级队列"]
            Q2["中优先级队列"]
            Q3["低优先级队列"]
            Q4["默认队列"]
        end
        
        subgraph Scheduler ["调度器"]
            S1["WRR调度"]
            S2["PQ调度"]
            S3["CBWFQ调度"]
            S4["流量整形"]
        end
        
        subgraph Interface ["链路层接口"]
            I1["以太网帧封装"]
            I2["PPP帧封装"]
            I3["光纤接口驱动"]
            I4["电接口驱动"]
        end
        
        Queue --> Scheduler
        Scheduler --> Interface
    end
    
    style Q1 fill:#e8f5e8,color:#333
    style Q2 fill:#e8f5e8,color:#333
    style Q3 fill:#e8f5e8,color:#333
    style Q4 fill:#e8f5e8,color:#333
    style S1 fill:#e3f2fd,color:#333
    style S2 fill:#e3f2fd,color:#333
    style S3 fill:#e3f2fd,color:#333
    style S4 fill:#e3f2fd,color:#333
    style I1 fill:#fff3e0,color:#333
    style I2 fill:#fff3e0,color:#333
    style I3 fill:#fff3e0,color:#333
    style I4 fill:#fff3e0,color:#333
```

#### 服务质量 (QoS) 实现

**分组调度算法**：

```
QoS调度算法对比：

1. 先进先出 (FIFO)：
   ┌─────┬─────┬─────┬─────┐
   │ P1  │ P2  │ P3  │ P4  │ → 发送顺序
   └─────┴─────┴─────┴─────┘
   • 最简单的调度
   • 无差别服务
   • 无QoS保证

2. 优先级队列 (Priority Queuing)：
   高优先级: [Voice] [Voice] → 优先发送
   中优先级: [Video] [Video]
   低优先级: [Data ] [Data ] → 最后发送
   
   • 严格优先级
   • 可能饿死低优先级流量
   • 适用于实时应用

3. 加权公平队列 (WFQ)：
   队列1 (权重3): ●●● → 获得3/8带宽
   队列2 (权重3): ●●● → 获得3/8带宽  
   队列3 (权重2): ●●  → 获得2/8带宽
   
   • 按权重分配带宽
   • 防止饿死现象
   • 提供带宽保证

4. 基于类的加权公平队列 (CBWFQ)：
```

```mermaid
graph TB
    A["总带宽 100Mbps"] --> B["Voice<br/>30Mbps<br/>(保证)"]
    A --> C["Video<br/>40Mbps<br/>(保证)"]
    A --> D["Data<br/>30Mbps<br/>(默认)"]
    
    style A fill:#f5f5f5,color:#333
    style B fill:#e8f5e8,color:#333
    style C fill:#fff3e0,color:#333
    style D fill:#e3f2fd,color:#333
```
   
```
   • 分层QoS设计
   • 带宽保证+突发支持
   • 企业网络主流方案

实际配置示例：
class-map voice
  match protocol rtp
  
class-map video  
  match protocol http
  
policy-map qos-policy
  class voice
    priority 30000    # 30Mbps保证带宽
  class video
    bandwidth 40000   # 40Mbps保证带宽
  class class-default
    bandwidth 30000   # 剩余带宽
```

---

## 排队理论与分组调度

### 排队模型分析

#### 基本排队理论

**M/M/1/K排队模型**：

```
路由器端口排队模型：
• M: 泊松分组到达过程
• M: 指数分布服务时间
• 1: 单一服务器（输出链路）
• K: 有限缓存容量

关键参数：
• λ: 平均到达速率 (pps)
• μ: 平均服务速率 (pps)  
• ρ = λ/μ: 利用率
• K: 缓存容量 (分组数)

性能指标：
1. 平均队列长度:
   L = ρ/(1-ρ) * [1-(K+1)ρ^K+Kρ^(K+1)] / [1-ρ^(K+1)]

2. 平均等待时间:
   W = L/λ

3. 丢包概率:
   P_loss = ρ^K(1-ρ)/(1-ρ^(K+1))

数值示例：
λ = 8000 pps, μ = 10000 pps, K = 100
ρ = 0.8
L ≈ 4.0 packets
W ≈ 0.5 ms  
P_loss ≈ 0.01%
```

#### 缓存管理策略

**主动队列管理 (AQM)**：


缓存管理算法：

1. 尾丢弃 (Tail Drop)：
```
   ┌─────┬─────┬─────┬─────┬─────┐ ← 缓存满
   │ P1  │ P2  │ P3  │ P4  │ P5  │
   └─────┴─────┴─────┴─────┴─────┘
                               ↓
                        新分组被丢弃
```
   
   问题：全局同步，TCP流同时退避

2. **随机早期检测 (RED)**：

**工作原理**：
   - **队列监控**：持续监测队列平均长度
   - **早期预警**：队列长度接近阈值时开始随机丢包
   - **避免拥塞**：防止队列溢出和全局同步

**关键参数**：

| 参数 | 含义 | 作用 |
|------|------|------|
| **Tmin** | 最小阈值 | 低于此值：无丢包 |
| **Tmax** | 最大阈值 | 高于此值：100%丢包 |
| **Pmax** | 最大丢包概率 | Tmin-Tmax区间的最大丢包率 |

**丢包策略**：
   - **绿色区域** (队列长度 < Tmin)：正常转发，无丢包
   - **黄色区域** (Tmin ≤ 队列长度 < Tmax)：线性增加丢包概率
     - 丢包概率 = (当前队列长度 - Tmin) / (Tmax - Tmin) × Pmax
   - **红色区域** (队列长度 ≥ Tmax)：强制丢包，丢包率100%
   
   优点：避免全局同步，提前预警

3. 加权随机早期检测 (WRED)：
   为不同服务类别设置不同的RED参数
   
   Premium类：Tmin=80, Tmax=100
   Gold类：   Tmin=60, Tmax=80  
   Best-effort类：Tmin=40, Tmax=60
   
   高优先级流量享受更大的缓存空间

4. 蓝色算法 (BLUE)：
   基于链路利用率和丢包率动态调整
```
   if (队列空闲时间 > freeze_time):
       p_mark -= d1
   if (检测到缓存溢出):
       p_mark += d2
```
   自适应调整丢包概率


### 流量控制机制

#### 流量整形技术

**流量控制算法**：

**流量整形方法**：

1. **令牌桶 (Token Bucket)**：

```mermaid
graph TD
    A["令牌生成器<br/>r tokens/sec"] --> B["令牌桶<br/>(B tokens)"]
    C["输入分组"] --> D["分组队列"]
    B --> |"每个分组<br/>消耗1个令牌"| D
    D --> E["输出分组"]
    
    style A fill:#f3e5f5,color:#333
    style B fill:#e8f5e8,color:#333
    style C fill:#e3f2fd,color:#333
    style D fill:#fff3e0,color:#333
    style E fill:#e3f2fd,color:#333
```
   
   参数：
   • r: 令牌填充速率 (bps)
   • B: 桶容量 (bytes)
   • 支持突发：最大B字节突发
   • 长期平均速率：r

2. **漏桶 (Leaky Bucket)**：
   分组输入 → ┌─────────────┐ → 固定速率输出
              │   缓存队列   │
              └─────────────┘
   
   • 严格限制输出速率
   • 平滑流量变化
   • 不支持突发传输

3. **双令牌桶 (Two-Token Bucket)**：

```mermaid
graph TD
    A["承诺速率CIR"] --> C["分配器"]
    B["峰值速率PIR"] --> C
    C --> D["承诺令牌桶CB"]
    C --> E["峰值令牌桶PB"]
    
    F["输入分组"] --> G["颜色标记"]
    D --> G
    E --> G
    G --> H["绿色：符合CIR"]
    G --> I["黄色：超过CIR但在PIR内"]
    G --> J["红色：超过PIR"]
    
    style A fill:#e8f5e8,color:#333
    style B fill:#fff3e0,color:#333
    style C fill:#f3e5f5,color:#333
    style D fill:#e8f5e8,color:#333
    style E fill:#fff3e0,color:#333
    style F fill:#e3f2fd,color:#333
    style G fill:#f3e5f5,color:#333
    style H fill:#e8f5e8,color:#333
    style I fill:#fff3e0,color:#333
    style J fill:#ffebee,color:#333
```

实际应用示例：
interface GigabitEthernet0/0
 rate-limit output 10000000 1875000 3750000 conform-action transmit exceed-action drop
 
参数解释：
• 10Mbps平均速率
• 1.875MB正常突发
• 3.75MB最大突发
• 符合速率：传输
• 超出速率：丢弃

---
 
**[下一节：4.3 Internet协议：IPv4与IPv6](4.3网络层：Internet协议IPv4技术.md)**
