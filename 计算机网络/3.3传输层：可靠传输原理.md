# 3.3 传输层：可靠传输原理

## 目录

1. [可靠传输概述](#可靠传输概述)
2. [可靠传输的基本机制](#可靠传输的基本机制)
3. [停等协议](#停等协议)
4. [滑动窗口协议](#滑动窗口协议)
5. [回退N步协议](#回退n步协议)
6. [选择重传协议](#选择重传协议)
7. [协议性能分析](#协议性能分析)

---

## 可靠传输概述

### 可靠传输的定义

> **可靠传输**
> 
> 确保发送方发送的数据能够正确、完整、有序地到达接收方，即使底层网络是不可靠的。

#### 不可靠网络的问题

**底层网络（IP协议）存在的问题**：

1. **数据丢失 (Loss)**
   - 路由器缓冲区溢出
   - 链路故障导致数据包丢失
   - 网络拥塞引起的丢包

2. **数据损坏 (Corruption)**
   - 传输过程中的比特错误
   - 电磁干扰造成的数据变化
   - 硬件故障导致的错误

3. **数据重复 (Duplication)**
   - 网络层的重传机制
   - 路由环路造成的重复
   - 设备故障引起的重复发送

4. **数据乱序 (Reordering)**
   - 不同路径的传输延迟差异
   - 负载均衡导致的乱序
   - 网络拓扑变化影响

### 可靠传输的目标

#### 核心保证

1. **无差错 (Error-free)**：数据内容正确
2. **不丢失 (Loss-free)**：所有数据都能到达
3. **不重复 (Duplicate-free)**：每个数据只传输一次
4. **保序 (In-order)**：数据按发送顺序到达

#### 性能指标

```
可靠性 ←→ 效率
  ↑        ↑
完全可靠   最高吞吐量
但效率低   但可能不可靠

目标：在保证可靠性的前提下尽量提高效率
```

### 可靠传输的实现层次

#### 1. 数据链路层可靠传输

**特点**：
- 点到点的可靠传输
- 距离短，错误率相对较低
- 主要处理传输错误

**典型协议**：HDLC、PPP

#### 2. 传输层可靠传输

**特点**：
- 端到端的可靠传输
- 跨越多个网络节点
- 处理网络层的所有不可靠因素

**典型协议**：TCP

#### 3. 应用层可靠传输

**特点**：
- 应用特定的可靠性需求
- 在UDP基础上实现定制化可靠性
- 灵活性高但复杂度大

**典型例子**：QUIC协议

---

## 可靠传输的基本机制

### 1. 错误检测 (Error Detection)

#### 校验和机制

**基本思想**：通过冗余信息检测传输错误

```
发送方：数据 + 计算校验和 = 数据包
         ↓ 网络传输
接收方：接收数据 + 重新计算校验和 → 比较 → 判断是否有错
```

**常用方法**：
- **奇偶校验**：简单但检测能力有限
- **CRC循环冗余校验**：检测能力强，广泛应用
- **MD5/SHA哈希**：强检测能力，计算开销大

#### CRC检测原理

```
数据：1010001101 (10位)
生成多项式：1101 (4位，检测3位错误)

计算过程：
1010001101000  (数据后补3个0)
      1101     (除以生成多项式)
      ----
      0111
       110
       ---  
       001
       000
       ---
       001101
        1101
        ----
        0000  → CRC = 000

发送：1010001101000 (原数据+CRC)
```

### 2. 确认 (Acknowledgment)

#### 确认机制

**正向确认**：
```
发送方 → 数据包 → 接收方
发送方 ← ACK确认 ← 接收方
```

**否定确认**：
```
发送方 → 损坏数据包 → 接收方
发送方 ← NAK拒绝 ← 接收方
```

#### 序号机制

**目的**：
- 识别不同的数据包
- 检测重复和丢失
- 保证数据有序

**序号空间**：
- **有限序号**：节省空间，需要考虑回绕
- **足够大**：避免活跃数据包的序号重复

### 3. 重传 (Retransmission)

#### 重传策略

**超时重传**：
```python
def send_with_timeout(packet, timeout=1.0):
    send_time = time.time()
    send_packet(packet)
    
    while True:
        if has_ack():
            ack = receive_ack()
            if ack.seq_num == packet.seq_num:
                return  # 成功
        
        if time.time() - send_time > timeout:
            send_packet(packet)  # 重传
            send_time = time.time()
```

**立即重传**：
```python
def handle_nak(nak):
    # 收到NAK立即重传
    packet = get_packet(nak.seq_num)
    send_packet(packet)
```

#### 超时时间设置

**固定超时时间**：
- 优点：简单
- 缺点：不能适应网络条件变化

**自适应超时时间**：
```python
# 指数加权移动平均
def update_rto(sample_rtt):
    global estimated_rtt, dev_rtt, rto
    
    if estimated_rtt is None:
        estimated_rtt = sample_rtt
        dev_rtt = sample_rtt / 2
    else:
        estimated_rtt = 0.875 * estimated_rtt + 0.125 * sample_rtt
        dev_rtt = 0.75 * dev_rtt + 0.25 * abs(sample_rtt - estimated_rtt)
    
    rto = estimated_rtt + 4 * dev_rtt
    return rto
```

### 4. 排序 (Ordering)

#### 序号排序

```python
class PacketBuffer:
    def __init__(self):
        self.buffer = {}
        self.expected_seq = 0
    
    def receive_packet(self, packet):
        self.buffer[packet.seq_num] = packet.data
        
        # 检查是否可以按序交付
        deliverable = []
        while self.expected_seq in self.buffer:
            deliverable.append(self.buffer.pop(self.expected_seq))
            self.expected_seq += 1
        
        return deliverable
```

---

## 停等协议

### 协议原理

> **停等协议 (Stop-and-Wait)**
> 
> 发送方发送一个数据包后必须等待接收方的确认，然后才能发送下一个数据包。

#### 基本流程

```
发送方                     接收方
  |                         |
  |-----> 数据包0 --------->|
  |                         | 检查无错
  |<----- ACK0 <-----------|
  |                         |
  |-----> 数据包1 --------->|
  |                         | 检查无错
  |<----- ACK1 <-----------|
  |                         |
```

### 正常情况处理

#### 无错误传输

```python
class StopAndWaitSender:
    def __init__(self):
        self.seq_num = 0
        self.timeout = 1.0
    
    def send_data(self, data):
        # 创建数据包
        packet = Packet(self.seq_num, data)
        
        while True:
            # 发送数据包
            send_packet(packet)
            start_timer(self.timeout)
            
            # 等待确认
            while timer_running():
                if has_ack():
                    ack = receive_ack()
                    if ack.seq_num == self.seq_num:
                        stop_timer()
                        self.seq_num = 1 - self.seq_num  # 0/1交替
                        return  # 成功
            
            # 超时，准备重传
            print(f"数据包{self.seq_num}超时，重传")

class StopAndWaitReceiver:
    def __init__(self):
        self.expected_seq = 0
    
    def receive_data(self):
        while True:
            packet = receive_packet()
            
            if packet.seq_num == self.expected_seq and not packet.corrupted():
                # 正确接收，发送确认
                deliver_data(packet.data)
                send_ack(self.expected_seq)
                self.expected_seq = 1 - self.expected_seq  # 0/1交替
            else:
                # 错误或重复，发送上一个确认
                prev_seq = 1 - self.expected_seq
                send_ack(prev_seq)
```

### 错误情况处理

#### 1. 数据包丢失

```
发送方                     接收方
  |                         |
  |-----> 数据包0 -------X  | (数据包丢失)
  |                         |
  |      (等待超时)          |
  |                         |
  |-----> 数据包0 --------->| (重传)
  |                         | 检查无错
  |<----- ACK0 <-----------|
  |                         |
```

#### 2. ACK丢失

```
发送方                     接收方
  |                         |
  |-----> 数据包0 --------->|
  |                         | 检查无错，发送ACK
  |  X<-- ACK0 <-----------| (ACK丢失)
  |                         |
  |      (等待超时)          |
  |                         |
  |-----> 数据包0 --------->| (重传，但接收方已收到)
  |                         | 检测重复，丢弃数据
  |<----- ACK0 <-----------| 重发ACK
  |                         |
```

#### 3. 数据包损坏

```
发送方                     接收方
  |                         |
  |-----> 数据包0 --------->| (数据损坏)
  |                         | 检测到错误
  |<----- NAK <------------| (可选：发送NAK)
  |                         |
  |-----> 数据包0 --------->| (立即或超时重传)
  |                         | 检查无错
  |<----- ACK0 <-----------|
  |                         |
```

### 停等协议特点

#### 优点

1. **实现简单**：逻辑清晰，易于理解和实现
2. **可靠性高**：确保每个数据包都被正确接收
3. **资源消耗少**：发送方只需维护一个数据包的状态

#### 缺点

1. **效率低下**：一次只能有一个数据包在传输
2. **网络利用率低**：大部分时间在等待确认
3. **延迟敏感**：RTT直接影响传输效率

### 停等协议性能分析

#### 信道利用率

**定义**：实际传输数据的时间占总时间的比例

```
设：
- L = 数据包大小 (bits)
- R = 传输速率 (bps)
- RTT = 往返时间 (seconds)

传输时间：t_trans = L / R
总周期时间：t_total = t_trans + RTT

信道利用率：U = t_trans / t_total = (L/R) / (L/R + RTT)

简化为：U = 1 / (1 + RTT·R/L)
```

#### 数值例子

```python
def calculate_utilization(packet_size, bandwidth, rtt):
    """计算停等协议的信道利用率"""
    trans_time = packet_size / bandwidth  # 传输时间
    total_time = trans_time + rtt         # 总周期时间
    return trans_time / total_time

# 例子1：局域网
print(f"局域网: {calculate_utilization(1000*8, 10e6, 0.001):.2%}")  
# 结果：约 89%

# 例子2：广域网  
print(f"广域网: {calculate_utilization(1000*8, 10e6, 0.1):.2%}")   
# 结果：约 7%

# 例子3：卫星链路
print(f"卫星链路: {calculate_utilization(1000*8, 10e6, 0.5):.2%}")  
# 结果：约 2%
```

---

## 滑动窗口协议

### 基本概念

> **滑动窗口 (Sliding Window)**
> 
> 允许发送方在收到确认之前发送多个数据包，从而提高网络利用率。

#### 窗口的概念

**发送窗口**：发送方可以发送但尚未确认的数据包范围

```
序号空间：... 0 1 2 3 4 5 6 7 8 9 10 11 12 ...
                 ←─── 发送窗口(大小=4) ───→
            已发送   可发送     不可发送
            等待确认  但未发送    
```

**接收窗口**：接收方可以接受的数据包范围

```
序号空间：... 0 1 2 3 4 5 6 7 8 9 10 11 12 ...
                 ←─── 接收窗口(大小=4) ───→
            已接收   可接收     不可接收
```

### 窗口滑动机制

#### 发送窗口滑动

```python
class SlidingWindowSender:
    def __init__(self, window_size):
        self.window_size = window_size
        self.base = 0  # 最早的未确认序号
        self.next_seq = 0  # 下一个要发送的序号
        self.packets = {}  # 缓存未确认的数据包
        
    def send_packet(self, data):
        if self.next_seq < self.base + self.window_size:
            # 窗口内，可以发送
            packet = Packet(self.next_seq, data)
            self.packets[self.next_seq] = packet
            
            transmit_packet(packet)
            if self.base == self.next_seq:
                start_timer()  # 为最早的数据包启动定时器
                
            self.next_seq += 1
            return True
        else:
            # 窗口满，无法发送
            return False
    
    def receive_ack(self, ack_num):
        if ack_num >= self.base:
            # 累积确认：确认 base 到 ack_num 的所有数据包
            for seq in range(self.base, ack_num + 1):
                if seq in self.packets:
                    del self.packets[seq]
            
            self.base = ack_num + 1
            
            if self.base == self.next_seq:
                stop_timer()  # 所有数据包都已确认
            else:
                restart_timer()  # 为新的最早数据包重启定时器
                
    def timeout_handler(self):
        # 重传所有未确认的数据包
        for seq in range(self.base, self.next_seq):
            if seq in self.packets:
                transmit_packet(self.packets[seq])
        restart_timer()
```

#### 接收窗口滑动

```python
class SlidingWindowReceiver:
    def __init__(self, window_size):
        self.window_size = window_size
        self.expected_base = 0  # 期望的最小序号
        self.buffer = {}  # 乱序数据包缓存
        
    def receive_packet(self, packet):
        seq_num = packet.seq_num
        
        if self.expected_base <= seq_num < self.expected_base + self.window_size:
            # 在接收窗口内
            if not packet.corrupted():
                self.buffer[seq_num] = packet.data
                
                # 检查是否可以交付连续的数据包
                deliverable = []
                while self.expected_base in self.buffer:
                    deliverable.append(self.buffer.pop(self.expected_base))
                    self.expected_base += 1
                
                # 发送累积确认
                send_ack(self.expected_base - 1)
                
                # 交付数据给应用层
                for data in deliverable:
                    deliver_data(data)
            
        elif seq_num < self.expected_base:
            # 重复的数据包，发送确认但丢弃数据
            send_ack(self.expected_base - 1)
        
        # 超出窗口的数据包直接丢弃
```

### 窗口大小的选择

#### 理论最优窗口大小

```
为了充分利用信道：

带宽时延乘积 = 带宽 × RTT

窗口大小 ≥ 带宽时延乘积 / 数据包大小

例子：
- 带宽：10 Mbps
- RTT：100 ms  
- 数据包大小：1000字节

窗口大小 ≥ (10×10⁶ × 0.1) / (1000×8) = 125 个数据包
```

#### 实际考虑因素

1. **内存限制**：缓存大量数据包需要内存
2. **序号空间**：避免序号重复使用
3. **流量控制**：考虑接收方的处理能力
4. **网络条件**：动态调整窗口大小

---

## 回退N步协议

### 协议原理

> **回退N步 (Go-Back-N, GBN)**
> 
> 发送方可以连续发送多个数据包，但出现错误时需要回退并重传N个数据包。

#### GBN特点

1. **发送方**：
   - 维护发送窗口
   - 使用累积确认
   - 超时时重传所有未确认数据包

2. **接收方**：
   - 只接受按序到达的数据包
   - 丢弃乱序数据包
   - 发送累积确认

### GBN工作流程

#### 正常情况

```
发送方                          接收方
  |                              |
  |-----> 数据包0 ------------->| 接收，期望序号0
  |-----> 数据包1 ------------->| 接收，期望序号1  
  |-----> 数据包2 ------------->| 接收，期望序号2
  |-----> 数据包3 ------------->| 接收，期望序号3
  |                              |
  |<----- ACK0 <----------------| 
  |<----- ACK1 <----------------| 
  |<----- ACK2 <----------------| 
  |<----- ACK3 <----------------| 
  |                              |
```

#### 数据包丢失情况

```
发送方                          接收方
  |                              |
  |-----> 数据包0 ------------->| 接收，发送ACK0
  |-----> 数据包1 -------X      | (数据包1丢失)
  |-----> 数据包2 ------------->| 乱序！丢弃，重发ACK0
  |-----> 数据包3 ------------->| 乱序！丢弃，重发ACK0
  |                              |
  |<----- ACK0 <----------------|
  |<----- ACK0 <----------------| (重复ACK)
  |<----- ACK0 <----------------| (重复ACK)
  |                              |
  |      (检测到重复ACK或超时)      |
  |                              |
  |-----> 数据包1 ------------->| 接收，发送ACK1
  |-----> 数据包2 ------------->| 接收，发送ACK2  
  |-----> 数据包3 ------------->| 接收，发送ACK3
  |                              |
```

### GBN实现

#### 发送方实现

```python
class GBNSender:
    def __init__(self, window_size):
        self.window_size = window_size
        self.base = 0  # 最早未确认序号
        self.next_seq = 0  # 下一个序号
        self.packets = {}  # 未确认数据包缓存
        self.timer = None
        
    def send_data(self, data):
        if self.next_seq < self.base + self.window_size:
            # 创建并发送数据包
            packet = Packet(self.next_seq, data)
            self.packets[self.next_seq] = packet
            
            transmit_packet(packet)
            
            # 如果是窗口中第一个数据包，启动定时器
            if self.base == self.next_seq:
                self.start_timer()
                
            self.next_seq += 1
            return True
        else:
            # 窗口满，拒绝发送
            return False
    
    def receive_ack(self, ack_num):
        if ack_num >= self.base:
            # 累积确认
            for seq in range(self.base, ack_num + 1):
                if seq in self.packets:
                    del self.packets[seq]
            
            self.base = ack_num + 1
            
            if self.base == self.next_seq:
                # 所有数据包已确认
                self.stop_timer()
            else:
                # 重启定时器为新的base
                self.restart_timer()
    
    def timeout_handler(self):
        # 回退N步：重传所有未确认数据包
        print(f"超时！回退重传序号 {self.base} 到 {self.next_seq-1}")
        
        for seq in range(self.base, self.next_seq):
            if seq in self.packets:
                transmit_packet(self.packets[seq])
                
        self.restart_timer()
```

#### 接收方实现

```python
class GBNReceiver:
    def __init__(self):
        self.expected_seq = 0
    
    def receive_packet(self, packet):
        if packet.corrupted():
            # 数据包损坏，丢弃
            return
            
        if packet.seq_num == self.expected_seq:
            # 按序到达
            deliver_data(packet.data)
            send_ack(self.expected_seq)
            self.expected_seq += 1
        else:
            # 乱序数据包，丢弃并重发最近的按序ACK
            if self.expected_seq > 0:
                send_ack(self.expected_seq - 1)
```

### GBN性能分析

#### 优点

1. **实现简单**：接收方只需维护一个期望序号
2. **内存开销小**：接收方无需缓存乱序数据包
3. **错误恢复快**：使用累积确认

#### 缺点

1. **重传开销大**：一个数据包丢失导致多个重传
2. **网络利用率低**：重传占用带宽
3. **延迟增加**：需要等待重传完成

#### 性能计算

```python
def gbn_efficiency(window_size, loss_rate, rtt, trans_time):
    """计算GBN协议效率"""
    if loss_rate == 0:
        # 无丢包情况下的理想效率
        return min(1.0, window_size * trans_time / (trans_time + rtt))
    
    # 考虑丢包的效率（简化模型）
    expected_retrans = window_size * loss_rate / (1 - loss_rate)
    effective_window = window_size + expected_retrans
    
    return window_size / effective_window

# 示例计算
print(f"GBN效率 (窗口=10, 丢包率=1%): {gbn_efficiency(10, 0.01, 0.1, 0.001):.2%}")
```

---

## 选择重传协议

### 协议原理

> **选择重传 (Selective Repeat, SR)**
> 
> 只重传丢失或损坏的数据包，接收方可以缓存乱序到达的数据包。

#### SR核心思想

```
GBN: 一个错误 → 重传多个数据包
SR:  一个错误 → 只重传一个数据包

优势：减少不必要的重传，提高网络效率
代价：增加复杂性，需要更多缓存
```

### SR工作流程

#### 数据包丢失情况

```
发送方                          接收方
  |                              |
  |-----> 数据包0 ------------->| 接收，缓存，发送ACK0
  |-----> 数据包1 -------X      | (数据包1丢失)
  |-----> 数据包2 ------------->| 接收，缓存，发送ACK2
  |-----> 数据包3 ------------->| 接收，缓存，发送ACK3
  |                              |
  |<----- ACK0 <----------------|
  |<----- ACK2 <----------------| (选择确认)
  |<----- ACK3 <----------------| (选择确认)
  |                              |
  |     (检测到数据包1丢失)        |
  |                              |
  |-----> 数据包1 ------------->| 接收，触发按序交付
  |                              | 交付数据包0,1,2,3
  |<----- ACK1 <----------------|
  |                              |
```

### SR实现

#### 发送方实现

```python
class SRSender:
    def __init__(self, window_size):
        self.window_size = window_size
        self.base = 0
        self.next_seq = 0
        self.packets = {}  # 未确认数据包
        self.timers = {}   # 每个数据包的定时器
        self.acked = set() # 已确认的序号
        
    def send_data(self, data):
        if self.next_seq < self.base + self.window_size:
            packet = Packet(self.next_seq, data)
            self.packets[self.next_seq] = packet
            
            transmit_packet(packet)
            self.start_timer(self.next_seq)  # 为每个数据包启动定时器
            
            self.next_seq += 1
            return True
        else:
            return False
    
    def receive_ack(self, ack_num):
        if self.base <= ack_num < self.base + self.window_size:
            # 标记为已确认
            self.acked.add(ack_num)
            
            if ack_num in self.packets:
                del self.packets[ack_num]
                
            if ack_num in self.timers:
                self.stop_timer(ack_num)
                del self.timers[ack_num]
            
            # 如果base已确认，滑动窗口
            if ack_num == self.base:
                while self.base in self.acked:
                    self.acked.remove(self.base)
                    self.base += 1
    
    def timeout_handler(self, seq_num):
        # 只重传超时的数据包
        if seq_num in self.packets:
            print(f"数据包{seq_num}超时，选择重传")
            transmit_packet(self.packets[seq_num])
            self.restart_timer(seq_num)

class SRReceiver:
    def __init__(self, window_size):
        self.window_size = window_size
        self.base = 0  # 期望的最小序号
        self.buffer = {}  # 乱序数据包缓存
        
    def receive_packet(self, packet):
        seq_num = packet.seq_num
        
        if packet.corrupted():
            return
            
        # 发送选择确认
        send_ack(seq_num)
        
        if self.base <= seq_num < self.base + self.window_size:
            # 在接收窗口内，缓存数据包
            if seq_num not in self.buffer:  # 避免重复
                self.buffer[seq_num] = packet.data
                
                # 检查是否可以按序交付
                deliverable = []
                while self.base in self.buffer:
                    deliverable.append(self.buffer.pop(self.base))
                    self.base += 1
                
                # 交付数据
                for data in deliverable:
                    deliver_data(data)
```

### 选择确认机制

#### SACK (Selective Acknowledgment)

```python
class SACKReceiver:
    def __init__(self, window_size):
        self.window_size = window_size
        self.base = 0
        self.received = set()  # 已接收的序号
        
    def generate_sack(self):
        """生成选择确认信息"""
        sack_blocks = []
        
        # 找出连续的已接收序号段
        sorted_received = sorted(self.received)
        if not sorted_received:
            return []
            
        start = sorted_received[0]
        end = sorted_received[0]
        
        for seq in sorted_received[1:]:
            if seq == end + 1:
                end = seq
            else:
                sack_blocks.append((start, end))
                start = end = seq
        
        sack_blocks.append((start, end))
        return sack_blocks
    
    def receive_packet(self, packet):
        seq_num = packet.seq_num
        
        if not packet.corrupted() and self.base <= seq_num < self.base + self.window_size:
            self.received.add(seq_num)
            
            # 生成SACK信息
            sack_info = self.generate_sack()
            send_sack(self.base - 1, sack_info)  # 累积ACK + 选择确认
            
            # 尝试按序交付
            deliverable = []
            while self.base in self.received:
                self.received.remove(self.base)
                # 这里需要从数据缓存中取出数据
                self.base += 1
```

### SR vs GBN 比较

#### 复杂性对比

| 方面 | GBN | SR |
|------|-----|----|
| **发送方** | 简单：一个定时器 | 复杂：多个定时器 |
| **接收方** | 简单：一个期望序号 | 复杂：缓存管理 |
| **确认机制** | 累积确认 | 选择确认 |
| **内存需求** | 低 | 高 |
| **实现难度** | 低 | 高 |

#### 性能对比

```python
def compare_protocols(window_size, loss_rate, bandwidth, rtt):
    """比较GBN和SR的性能"""
    
    # GBN性能（简化模型）
    gbn_retrans_ratio = window_size * loss_rate / (1 - loss_rate)
    gbn_efficiency = 1 / (1 + gbn_retrans_ratio)
    
    # SR性能（简化模型）  
    sr_retrans_ratio = loss_rate
    sr_efficiency = 1 - sr_retrans_ratio
    
    print(f"窗口大小: {window_size}, 丢包率: {loss_rate:.1%}")
    print(f"GBN效率: {gbn_efficiency:.1%}")
    print(f"SR效率: {sr_efficiency:.1%}")
    print(f"SR相对提升: {(sr_efficiency/gbn_efficiency-1):.1%}")
    print()

# 性能比较
compare_protocols(10, 0.01, 1e6, 0.1)
compare_protocols(10, 0.05, 1e6, 0.1)
compare_protocols(10, 0.10, 1e6, 0.1)
```

---

## 协议性能分析

### 吞吐量分析

#### 理论吞吐量

```
无错信道：
吞吐量 = min(窗口大小, 带宽时延乘积) × 数据包大小 / RTT

有错信道：
吞吐量 = 理论吞吐量 × (1 - 重传开销)
```

#### 重传开销计算

**停等协议**：
```python
def stop_wait_overhead(loss_rate):
    # 平均重传次数
    avg_retrans = loss_rate / (1 - loss_rate)
    return avg_retrans

**GBN协议**：
def gbn_overhead(window_size, loss_rate):
    # 一个数据包丢失导致窗口内所有后续数据包重传
    return window_size * loss_rate / (1 - loss_rate)

**SR协议**：
def sr_overhead(loss_rate):
    # 只重传丢失的数据包
    return loss_rate / (1 - loss_rate)
```

### 延迟分析

#### 端到端延迟组成

```
总延迟 = 传播延迟 + 传输延迟 + 排队延迟 + 处理延迟 + 重传延迟

重传延迟 = 平均重传次数 × RTT
```

#### 协议延迟对比

```python
def calculate_delay(protocol, window_size, loss_rate, rtt, trans_time):
    """计算不同协议的平均延迟"""
    
    base_delay = rtt + trans_time
    
    if protocol == "stop_wait":
        # 停等：每个数据包都需要等待确认
        retrans_delay = (loss_rate / (1 - loss_rate)) * rtt
        return base_delay + retrans_delay
        
    elif protocol == "gbn":
        # GBN：需要等待整个窗口重传
        retrans_delay = (window_size * loss_rate / (1 - loss_rate)) * rtt
        return base_delay + retrans_delay / window_size  # 平摊到每个数据包
        
    elif protocol == "sr":
        # SR：只需要重传丢失的数据包
        retrans_delay = (loss_rate / (1 - loss_rate)) * rtt
        return base_delay + retrans_delay
        
# 示例比较
protocols = ["stop_wait", "gbn", "sr"]
for protocol in protocols:
    delay = calculate_delay(protocol, 10, 0.05, 0.1, 0.001)
    print(f"{protocol.upper()} 平均延迟: {delay:.3f}s")
```

### 协议选择指南

#### 选择决策树

```
网络丢包率高？
├─ 是 → 带宽充足？
│      ├─ 是 → 选择SR（减少重传）
│      └─ 否 → 选择GBN（节省内存）
└─ 否 → 实现复杂度要求？
       ├─ 低 → 选择Stop-Wait或GBN
       └─ 可接受 → 选择SR（最优性能）
```

#### 应用场景匹配

| 应用场景 | 推荐协议 | 原因 |
|----------|----------|------|
| 卫星通信 | SR | 高延迟，重传代价大 |
| 局域网 | GBN | 低延迟，实现简单 |
| 移动网络 | SR | 高丢包率，带宽宝贵 |
| 传感器网络 | Stop-Wait | 资源受限，简单可靠 |
| 实时应用 | SR + 定制 | 低延迟，选择重传 |

### 现代改进技术

#### 1. 快速重传

```python
class FastRetransmit:
    def __init__(self, dup_ack_threshold=3):
        self.dup_ack_threshold = dup_ack_threshold
        self.dup_ack_count = 0
        self.last_ack = -1
    
    def receive_ack(self, ack_num):
        if ack_num == self.last_ack:
            self.dup_ack_count += 1
            if self.dup_ack_count >= self.dup_ack_threshold:
                # 触发快速重传
                self.fast_retransmit(ack_num + 1)
                self.dup_ack_count = 0
        else:
            self.last_ack = ack_num
            self.dup_ack_count = 0
```

#### 2. 自适应超时

```python
class AdaptiveTimeout:
    def __init__(self):
        self.srtt = None  # 平滑RTT
        self.rttvar = None  # RTT变化量
        self.rto = 1.0    # 重传超时时间
        
    def update_rtt(self, sample_rtt):
        if self.srtt is None:
            self.srtt = sample_rtt
            self.rttvar = sample_rtt / 2
        else:
            alpha = 0.125
            beta = 0.25
            self.rttvar = (1 - beta) * self.rttvar + beta * abs(sample_rtt - self.srtt)
            self.srtt = (1 - alpha) * self.srtt + alpha * sample_rtt
        
        self.rto = self.srtt + 4 * self.rttvar
        self.rto = max(0.2, min(60.0, self.rto))  # 限制范围
        
        return self.rto
```

### 本章小结

#### 核心概念总结

1. **可靠传输目标**：无差错、不丢失、不重复、保序
2. **基本机制**：错误检测、确认、重传、排序
3. **协议演进**：停等 → GBN → SR，复杂性递增，性能递优
4. **性能权衡**：可靠性 vs 效率，简单性 vs 最优性

#### 关键技术要点

- **窗口机制**：提高网络利用率的核心技术
- **确认策略**：累积确认 vs 选择确认的权衡
- **重传机制**：超时重传 vs 快速重传
- **序号管理**：避免序号重复，处理序号回绕

#### 实际应用指导

1. **协议选择**：根据网络条件和应用需求选择合适协议
2. **参数调优**：窗口大小、超时时间的优化设置  
3. **现代改进**：结合快速重传、自适应超时等技术
4. **性能监控**：实时监测协议性能，动态调整参数

---

**[下一节：3.4 TCP协议基础](3.4传输层：TCP协议基础.md)**
