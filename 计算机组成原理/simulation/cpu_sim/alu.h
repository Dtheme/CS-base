#ifndef CPU_SIM_ALU_H
#define CPU_SIM_ALU_H

#include "../common/types.h"

/**
 * ALU (算术逻辑单元) 模块
 * 
 * 设计原理：
 * ALU是CPU的核心运算部件，负责执行所有的算术和逻辑运算操作。
 * 本模块采用统一的运算接口设计，支持完整的指令集运算需求。
 * 
 * 架构特点：
 * 1. 功能完备性 - 支持算术、逻辑、移位、比较等全类型运算
 * 2. 标志位系统 - 完整的ZNCO标志位机制，支持条件判断
 * 3. 状态保持 - 维护运算历史和当前状态信息
 * 4. 错误处理 - 完善的边界检查和异常处理机制
 * 5. 调试支持 - 丰富的状态查询和调试输出功能
 * 
 * 运算流水：
 * 操作数输入 -> 运算执行 -> 结果计算 -> 标志位更新 -> 结果输出
 * 
 * 标志位机制：
 * - Zero (Z): 结果为零
 * - Negative (N): 结果为负（符号位为1）
 * - Carry (C): 进位/借位标志
 * - Overflow (V): 有符号数溢出标志
 */

// ==================== ALU操作类型定义 ====================

/**
 * ALU运算操作枚举
 * 
 * 操作分类：
 * - 算术运算 (0-3, 13-15): 基础数学运算
 * - 逻辑运算 (4-7): 位级逻辑操作
 * - 移位运算 (8-11): 位移和循环操作
 * - 比较运算 (12): 数值大小关系判断
 * 
 * 编码设计：
 * 采用连续编码便于数组索引和跳转表实现
 * 预留扩展空间支持后续指令集扩展
 */
typedef enum {
    ALU_ADD = 0,    // 加法运算 - 二进制补码加法
    ALU_SUB = 1,    // 减法运算 - 通过加法器实现 (A + (-B))
    ALU_MUL = 2,    // 乘法运算 - 移位累加算法
    ALU_DIV = 3,    // 除法运算 - 非恢复除法算法
    ALU_AND = 4,    // 逻辑与 - 按位AND操作
    ALU_OR  = 5,    // 逻辑或 - 按位OR操作
    ALU_XOR = 6,    // 逻辑异或 - 按位XOR操作
    ALU_NOT = 7,    // 逻辑非 - 按位取反操作
    ALU_SHL = 8,    // 算术左移 - 向左移位，右侧补0
    ALU_SHR = 9,    // 算术右移 - 向右移位，保持符号位
    ALU_ROL = 10,   // 循环左移 - 位循环，无数据丢失
    ALU_ROR = 11,   // 循环右移 - 位循环，无数据丢失
    ALU_CMP = 12,   // 比较运算 - 执行减法但不保存结果
    ALU_INC = 13,   // 自增运算 - 操作数+1
    ALU_DEC = 14,   // 自减运算 - 操作数-1
    ALU_NEG = 15    // 取负运算 - 二进制补码取负
} alu_op_t;

// ==================== ALU标志位定义 ====================

/**
 * ALU标志位掩码
 * 
 * 标志位布局 (8位寄存器)：
 * Bit 0 (Z): Zero Flag      - 结果为零时置1
 * Bit 1 (N): Negative Flag  - 结果为负时置1 (符号位)
 * Bit 2 (C): Carry Flag     - 进位/借位时置1
 * Bit 3 (V): Overflow Flag  - 有符号溢出时置1
 * Bit 4-7:   保留位        - 预留给扩展标志
 * 
 * 标志位计算原理：
 * - Z: result == 0
 * - N: result[31] == 1 (最高位为符号位)
 * - C: 无符号运算进位/借位检测
 * - V: 有符号运算溢出检测 (符号位进位与最高位进位不同)
 */
#define ALU_FLAG_ZERO       0x01  // 零标志位
#define ALU_FLAG_NEGATIVE   0x02  // 负数标志位
#define ALU_FLAG_CARRY      0x04  // 进位标志位
#define ALU_FLAG_OVERFLOW   0x08  // 溢出标志位

// ==================== ALU数据结构定义 ====================

/**
 * ALU运算结果结构体
 * 
 * 设计理念：
 * 封装单次运算的完整结果信息，包括数值结果、标志位状态和有效性标识
 * 
 * 字段说明：
 * - result: 32位运算结果，支持有符号和无符号解释
 * - flags: 8位标志位寄存器，记录运算产生的状态
 * - valid: 运算有效性标志，用于错误检测和异常处理
 */
typedef struct {
    word_t result;      // 32位运算结果
    u8 flags;           // 标志位寄存器
    bool valid;         // 结果有效性标志
} alu_result_t;

/**
 * ALU状态结构体
 * 
 * 架构设计：
 * 模拟真实CPU中ALU的硬件结构，维护运算状态和历史信息
 * 
 * 状态信息：
 * - operation: 最后执行的运算类型，用于调试和状态查询
 * - result: 最后一次运算的完整结果信息
 * - flags: 当前标志位状态，影响条件跳转和分支判断
 * - operand_a/b: 最后一次运算的操作数，用于调试和重复运算
 * 
 * 使用模式：
 * 1. 单次运算：直接调用具体运算函数
 * 2. 状态跟踪：通过ALU结构体维护运算历史
 * 3. 批量运算：复用ALU实例进行连续计算
 */
typedef struct {
    alu_op_t operation;     // 当前/最后执行的操作类型
    alu_result_t result;    // 最后一次运算结果
    u8 flags;               // ALU标志位寄存器
    word_t operand_a;       // 操作数A (被操作数)
    word_t operand_b;       // 操作数B (操作数)
} alu_t;

// ==================== ALU生命周期管理 ====================

/**
 * 初始化ALU实例
 * 
 * 初始化过程：
 * 1. 清零所有寄存器和状态变量
 * 2. 设置默认操作类型为NOP
 * 3. 标记结果为无效状态
 * 4. 执行内部自检和验证
 * 
 * @param alu ALU结构指针，不能为NULL
 * @return 成功返回CPU_SUCCESS，参数无效返回CPU_ERROR_NULL_POINTER
 */
cpu_error_t alu_init(alu_t *alu);

/**
 * 重置ALU状态
 * 
 * 重置范围：
 * - 清除所有标志位
 * - 清零操作数寄存器
 * - 重置运算结果
 * - 保持ALU实例有效性
 * 
 * 应用场景：
 * - 程序开始前的状态清理
 * - 异常恢复后的状态重置
 * - 测试用例间的状态隔离
 * 
 * @param alu ALU结构指针，允许为NULL（安全忽略）
 */
void alu_reset(alu_t *alu);

// ==================== ALU运算执行 ====================

/**
 * 执行ALU综合运算
 * 
 * 执行流程：
 * 1. 参数验证和范围检查
 * 2. 根据操作类型分发到具体运算函数
 * 3. 执行运算并计算标志位
 * 4. 更新ALU内部状态
 * 5. 返回完整运算结果
 * 
 * 状态更新：
 * - 保存操作数和操作类型
 * - 更新标志位寄存器
 * - 缓存运算结果
 * 
 * 错误处理：
 * - 除零检测和处理
 * - 无效操作类型检测
 * - 参数范围验证
 * 
 * @param alu ALU结构指针
 * @param op 运算操作类型
 * @param a 操作数A（被操作数）
 * @param b 操作数B（操作数）
 * @return ALU运算结果，包含数值和标志位
 */
alu_result_t alu_execute(alu_t *alu, alu_op_t op, word_t a, word_t b);

/**
 * 获取ALU最后运算结果
 * 
 * 返回值：
 * - result.valid == true: 结果有效，可正常使用
 * - result.valid == false: 结果无效，需检查错误状态
 * 
 * @param alu ALU结构指针，不能为NULL
 * @return 最后一次运算的完整结果
 */
alu_result_t alu_get_result(const alu_t *alu);

// ==================== 基本算术运算 ====================

/**
 * 二进制补码加法运算
 * 
 * 算法实现：
 * 1. 直接使用CPU加法指令执行32位加法
 * 2. 检测无符号进位：result < a 或 result < b
 * 3. 检测有符号溢出：(a^result) & (b^result) & 0x80000000
 * 4. 更新所有相关标志位
 * 
 * 标志位计算：
 * - Z: result == 0
 * - N: result & 0x80000000
 * - C: (uint64_t)a + b > UINT32_MAX
 * - V: 符号位进位异或检测
 * 
 * @param a 加数A
 * @param b 加数B
 * @return 加法运算结果及标志位
 */
alu_result_t alu_add(word_t a, word_t b);

/**
 * 二进制补码减法运算
 * 
 * 实现策略：
 * 减法通过加法实现：A - B = A + (-B) = A + (~B + 1)
 * 
 * 算法步骤：
 * 1. 计算B的二进制补码：~B + 1
 * 2. 执行加法运算：A + (-B)
 * 3. 调整标志位语义以符合减法定义
 * 
 * 借位检测：
 * 减法的借位等价于加法的进位取反
 * 
 * @param a 被减数
 * @param b 减数
 * @return 减法运算结果及标志位
 */
alu_result_t alu_sub(word_t a, word_t b);

/**
 * 无符号乘法运算
 * 
 * 算法选择：
 * 对于32位乘法，使用64位中间结果避免溢出
 * 
 * 实现要点：
 * 1. 将操作数扩展到64位执行乘法
 * 2. 检查高32位是否非零判断溢出
 * 3. 截取低32位作为最终结果
 * 4. 设置相应的标志位
 * 
 * 性能优化：
 * 利用编译器优化和硬件乘法器
 * 
 * @param a 乘数A
 * @param b 乘数B
 * @return 乘法运算结果及标志位
 */
alu_result_t alu_mul(word_t a, word_t b);

/**
 * 无符号除法运算
 * 
 * 算法实现：
 * 采用标准整数除法，返回商作为结果
 * 
 * 异常处理：
 * 1. 除零检测：除数为0时返回无效结果
 * 2. 设置相应错误标志
 * 3. 不抛出异常，通过返回值指示错误
 * 
 * 标志位设置：
 * - Z: 商为0
 * - N: 商的符号位
 * - C: 总是清零（除法不产生进位）
 * - V: 除零时置1
 * 
 * @param a 被除数
 * @param b 除数（不能为0）
 * @return 除法运算结果及标志位
 */
alu_result_t alu_div(word_t a, word_t b);

// ==================== 逻辑运算 ====================

/**
 * 按位逻辑与运算
 * 
 * 运算规则：
 * 对应位同时为1时结果为1，否则为0
 * 
 * 真值表：
 * A | B | A&B
 * 0 | 0 |  0
 * 0 | 1 |  0
 * 1 | 0 |  0
 * 1 | 1 |  1
 * 
 * 应用场景：
 * - 位掩码操作
 * - 条件清零
 * - 特定位提取
 * 
 * @param a 操作数A
 * @param b 操作数B
 * @return 逻辑与运算结果
 */
alu_result_t alu_and(word_t a, word_t b);

/**
 * 按位逻辑或运算
 * 
 * 运算规则：
 * 对应位至少一个为1时结果为1
 * 
 * 真值表：
 * A | B | A|B
 * 0 | 0 |  0
 * 0 | 1 |  1
 * 1 | 0 |  1
 * 1 | 1 |  1
 * 
 * 应用场景：
 * - 位设置操作
 * - 数据合并
 * - 标志位组合
 * 
 * @param a 操作数A
 * @param b 操作数B
 * @return 逻辑或运算结果
 */
alu_result_t alu_or(word_t a, word_t b);

/**
 * 按位逻辑异或运算
 * 
 * 运算规则：
 * 对应位不同时结果为1，相同时为0
 * 
 * 真值表：
 * A | B | A^B
 * 0 | 0 |  0
 * 0 | 1 |  1
 * 1 | 0 |  1
 * 1 | 1 |  0
 * 
 * 特殊性质：
 * - A ^ A = 0 (自异或为0)
 * - A ^ 0 = A (与0异或不变)
 * - A ^ B ^ B = A (异或可逆)
 * 
 * 应用场景：
 * - 位翻转操作
 * - 简单加密
 * - 奇偶校验
 * 
 * @param a 操作数A
 * @param b 操作数B
 * @return 逻辑异或运算结果
 */
alu_result_t alu_xor(word_t a, word_t b);

/**
 * 按位逻辑非运算
 * 
 * 运算规则：
 * 每一位取反，0变1，1变0
 * 
 * 实现：
 * 使用按位取反操作符 (~)
 * 
 * 注意事项：
 * 逻辑非是一元运算，只需要一个操作数
 * 
 * @param a 操作数A
 * @return 逻辑非运算结果
 */
alu_result_t alu_not(word_t a);

// ==================== 移位运算 ====================

/**
 * 逻辑左移运算
 * 
 * 移位规则：
 * 1. 所有位向左移动指定位数
 * 2. 右侧空位用0填充
 * 3. 左侧移出的位丢失
 * 
 * 数学意义：
 * 左移n位等价于乘以2^n（不考虑溢出）
 * 
 * 溢出检测：
 * 移出的位中包含1时发生溢出
 * 
 * 边界处理：
 * - 移位数 >= 32：结果为0
 * - 移位数 == 0：结果不变
 * 
 * @param a 被移位的操作数
 * @param shift 移位位数（0-31有效）
 * @return 左移运算结果
 */
alu_result_t alu_shl(word_t a, u8 shift);

/**
 * 算术右移运算
 * 
 * 移位规则：
 * 1. 所有位向右移动指定位数
 * 2. 左侧用符号位填充（保持符号）
 * 3. 右侧移出的位丢失
 * 
 * 符号扩展：
 * - 正数：左侧填充0
 * - 负数：左侧填充1
 * 
 * 数学意义：
 * 算术右移n位等价于除以2^n并向负无穷舍入
 * 
 * @param a 被移位的操作数
 * @param shift 移位位数（0-31有效）
 * @return 算术右移运算结果
 */
alu_result_t alu_shr(word_t a, u8 shift);

/**
 * 循环左移运算
 * 
 * 循环规则：
 * 1. 所有位向左移动指定位数
 * 2. 左侧移出的位从右侧移入
 * 3. 不丢失任何位信息
 * 
 * 实现算法：
 * result = (a << shift) | (a >> (32 - shift))
 * 
 * 周期性：
 * 循环移位32次后回到原始值
 * 
 * @param a 被移位的操作数
 * @param shift 移位位数（0-31有效）
 * @return 循环左移运算结果
 */
alu_result_t alu_rol(word_t a, u8 shift);

/**
 * 循环右移运算
 * 
 * 循环规则：
 * 1. 所有位向右移动指定位数
 * 2. 右侧移出的位从左侧移入
 * 3. 不丢失任何位信息
 * 
 * 实现算法：
 * result = (a >> shift) | (a << (32 - shift))
 * 
 * 应用场景：
 * - 数据加密算法
 * - 哈希函数
 * - 循环冗余校验
 * 
 * @param a 被移位的操作数
 * @param shift 移位位数（0-31有效）
 * @return 循环右移运算结果
 */
alu_result_t alu_ror(word_t a, u8 shift);

// ==================== 比较运算 ====================

/**
 * 数值比较运算
 * 
 * 比较实现：
 * 通过减法运算实现，但不保存减法结果
 * 仅更新标志位以反映比较关系
 * 
 * 标志位含义：
 * - Z=1: a == b (相等)
 * - Z=0, N=0: a > b (大于，有符号)
 * - Z=0, N=1: a < b (小于，有符号)
 * - C=1: a < b (小于，无符号)
 * - C=0: a >= b (大于等于，无符号)
 * 
 * 比较类型：
 * 支持有符号和无符号两种比较语义
 * 通过不同标志位组合判断各种关系
 * 
 * @param a 比较操作数A
 * @param b 比较操作数B
 * @return 比较结果（通过标志位表示关系）
 */
alu_result_t alu_cmp(word_t a, word_t b);

// ==================== 标志位操作 ====================

/**
 * 计算并设置零标志位
 * 
 * 判断规则：
 * 运算结果的所有位都为0时，零标志位置1
 * 
 * @param result 运算结果
 * @return 零标志位值（true表示结果为零）
 */
bool alu_set_zero_flag(word_t result);

/**
 * 计算并设置进位标志位
 * 
 * 进位检测算法：
 * 1. 加法进位：(uint64_t)a + b > UINT32_MAX
 * 2. 减法借位：a < b
 * 3. 移位进位：检查移出位是否包含1
 * 
 * 应用场景：
 * - 多精度运算
 * - 无符号数比较
 * - 条件分支判断
 * 
 * @param a 操作数A
 * @param b 操作数B
 * @param result 运算结果
 * @return 进位标志位值
 */
bool alu_set_carry_flag(word_t a, word_t b, word_t result);

/**
 * 计算并设置溢出标志位
 * 
 * 溢出检测原理：
 * 有符号运算溢出发生在：
 * - 正数 + 正数 = 负数
 * - 负数 + 负数 = 正数
 * - 正数 - 负数 = 负数
 * - 负数 - 正数 = 正数
 * 
 * 检测算法：
 * ((a ^ result) & (b ^ result) & 0x80000000) != 0
 * 
 * 标志位用途：
 * - 有符号数运算验证
 * - 异常检测和处理
 * - 编译器优化提示
 * 
 * @param a 操作数A
 * @param b 操作数B
 * @param result 运算结果
 * @return 溢出标志位值
 */
bool alu_set_overflow_flag(word_t a, word_t b, word_t result);

/**
 * 计算并设置负数标志位
 * 
 * 判断规则：
 * 运算结果的最高位（符号位）为1时，负数标志位置1
 * 
 * 符号位定义：
 * 在二进制补码表示中，最高位表示数的正负性
 * 
 * @param result 运算结果
 * @return 负数标志位值（true表示结果为负）
 */
bool alu_set_negative_flag(word_t result);

// ==================== 调试和工具函数 ====================

/**
 * ALU操作类型转字符串
 * 
 * 用途：
 * - 调试输出和日志记录
 * - 错误信息格式化
 * - 用户界面显示
 * 
 * @param op ALU操作类型枚举值
 * @return 操作类型的字符串表示
 */
const char* alu_op_to_string(alu_op_t op);

/**
 * 格式化打印ALU当前状态
 * 
 * 输出信息：
 * - 当前操作类型
 * - 操作数值
 * - 运算结果
 * - 标志位状态
 * 
 * @param alu ALU结构指针
 */
void alu_print_status(const alu_t *alu);

/**
 * 格式化打印ALU运算结果
 * 
 * 输出格式：
 * - 十六进制结果值
 * - 标志位状态显示
 * - 结果有效性标识
 * 
 * @param result ALU运算结果指针
 */
void alu_print_result(const alu_result_t *result);

/**
 * 验证ALU运算结果的有效性
 * 
 * 验证项目：
 * - 结果指针非空
 * - valid标志位正确
 * - 标志位值在合理范围内
 * 
 * @param result ALU运算结果指针
 * @return 结果有效返回true，否则返回false
 */
bool alu_validate_result(const alu_result_t *result);

/**
 * 转储ALU完整状态信息
 * 
 * 调试信息：
 * - 内存地址和大小
 * - 所有字段的详细值
 * - 内部状态一致性检查
 * 
 * 用途：
 * - 深度调试分析
 * - 状态快照保存
 * - 问题定位诊断
 * 
 * @param alu ALU结构指针
 */
void alu_dump(const alu_t *alu);

#endif // CPU_SIM_ALU_H 